<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apology Quest: è¬ç½ªã®ç‹æ§˜</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');

        :root {
            --bg-color: #202028;
            --window-bg: #0000aa; /* Classic RPG Blue */
            --window-border: #ffffff;
            --text-color: #ffffff;
            --accent-color: #f1c40f;
            --danger-color: #e74c3c;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'DotGothic16', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* Game Container */
        #game-container {
            width: 100%;
            max-width: 600px;
            height: 100vh;
            max-height: 800px;
            position: relative;
            display: flex;
            flex-direction: column;
            background-color: #000;
        }

        /* Screen Area (Visuals) */
        #screen-area {
            flex: 1;
            background-color: #111;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            border-bottom: 4px solid var(--window-border);
        }

        /* Character Display */
        .character {
            font-size: 8rem;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 10px rgba(255,255,255,0.2));
            transition: transform 0.2s;
        }
        .shake {
            animation: shake 0.5s;
        }
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        /* Status Bar */
        #status-bar {
            width: 90%;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2rem;
        }

        .hp-bar-container {
            width: 200px;
            height: 20px;
            background-color: #333;
            border: 2px solid white;
            position: relative;
        }

        .hp-bar-fill {
            height: 100%;
            background-color: var(--accent-color);
            width: 100%;
            transition: width 0.3s ease, background-color 0.3s;
        }

        /* Dialogue Box */
        #dialogue-box {
            height: 30%;
            background-color: var(--window-bg);
            border: 4px solid var(--window-border);
            border-radius: 4px;
            margin: 10px;
            padding: 20px;
            position: relative;
            box-shadow: 0 0 0 4px #000, 0 0 0 8px var(--window-border); 
            cursor: pointer;
        }

        #speaker-name {
            font-size: 1.2rem;
            color: var(--accent-color);
            margin-bottom: 10px;
            font-weight: bold;
        }

        #message-text {
            font-size: 1.4rem;
            line-height: 1.6;
            white-space: pre-wrap; /* Preserve newlines */
            min-height: 3em;
        }

        /* Blinking Cursor/Arrow */
        #next-indicator {
            position: absolute;
            bottom: 15px;
            right: 20px;
            font-size: 1.5rem;
            animation: blink 1s infinite;
            display: none;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* Choices Overlay */
        #choices-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }

        .choice-btn {
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #fff;
            color: #fff;
            padding: 15px;
            font-family: 'DotGothic16', sans-serif;
            font-size: 1.2rem;
            cursor: pointer;
            text-align: left;
            transition: background-color 0.2s;
        }

        .choice-btn:hover {
            background-color: var(--window-bg);
            border-color: var(--accent-color);
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        h1 {
            color: var(--accent-color);
            font-size: 3rem;
            text-shadow: 4px 4px var(--window-bg);
            margin-bottom: 2rem;
            text-align: center;
        }
        
        .start-btn {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 1.5rem;
        }

    </style>
</head>
<body>

<div id="game-container">
    
    <!-- Visuals -->
    <div id="screen-area">
        <div id="status-bar">
            <span>TARGET: <span id="target-name">???</span></span>
            <div style="display:flex; align-items:center; gap:10px;">
                <span>ä¿¡é ¼åº¦:</span>
                <div class="hp-bar-container">
                    <div id="hp-bar" class="hp-bar-fill"></div>
                </div>
            </div>
        </div>
        <div id="character-display" class="character">ğŸ˜</div>
    </div>

    <!-- Dialogue Box -->
    <div id="dialogue-box" onclick="handleDialogueClick()">
        <div id="speaker-name"></div>
        <div id="message-text"></div>
        <div id="next-indicator">â–¼</div>
    </div>

    <!-- Choices -->
    <div id="choices-container">
        <!-- Buttons injected by JS -->
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1>Apology<br>Quest</h1>
        <p>ã€Œä½•ã«å¯¾ã—ã¦ã€è¬ã‚‹ã®ã‹ã€‚<br>ãã‚Œã‚’è¦‹æ¥µã‚ã‚‹RPGã€‚</p>
        <button class="choice-btn start-btn" onclick="startGame('romance')">ã‚·ãƒŠãƒªã‚ª1ï¼šæ€’ã‚Œã‚‹æ‹äºº</button>
        <button class="choice-btn start-btn" onclick="startGame('business')">ã‚·ãƒŠãƒªã‚ª2ï¼šæ¿€æ€’ä¸Šå¸</button>
    </div>

</div>

<script>
    /**
     * Game State & Configuration
     */
    const gameState = {
        currentScenario: null,
        currentNodeId: 'start',
        trust: 100, // HP
        isTyping: false,
        fullText: '',
        timerId: null,
        isWaitingForInput: false
    };

    // DOM Elements
    const els = {
        dialogueBox: document.getElementById('dialogue-box'),
        speakerName: document.getElementById('speaker-name'),
        messageText: document.getElementById('message-text'),
        nextIndicator: document.getElementById('next-indicator'),
        choicesContainer: document.getElementById('choices-container'),
        startScreen: document.getElementById('start-screen'),
        hpBar: document.getElementById('hp-bar'),
        character: document.getElementById('character-display'),
        targetName: document.getElementById('target-name')
    };

    /**
     * Scenarios Data
     * structure:
     * id: {
     * speaker: string,
     * text: string,
     * emotion: emoji string,
     * choices: [ { text: string, next: string, damage: number } ]
     * next: string (if no choices, simple transition)
     * }
     */
    const scenarios = {
        // --- SCENARIO 1: Romance ---
        'romance': {
            'start': {
                speaker: 'ãƒŠãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³',
                text: 'ã‚ãªãŸã¯ç´„æŸã®ãƒ‡ãƒ¼ãƒˆã«1æ™‚é–“é…åˆ»ã—ãŸã€‚\nå½¼å¥³ã¯è…•ã‚’çµ„ã‚“ã§å¾…ã£ã¦ã„ã‚‹...',
                emotion: 'ğŸ˜',
                next: 'intro'
            },
            'intro': {
                speaker: 'å½¼å¥³',
                text: 'â€¦â€¦ä»Šã€ä½•æ™‚ã ã¨æ€ã£ã¦ã‚‹ã®ï¼Ÿ',
                emotion: 'ğŸ˜ ',
                choices: [
                    { text: 'ã”ã‚ã‚“ï¼', next: 'vague_apology', damage: 20 },
                    { text: 'æœ¬å½“ã«ç”³ã—è¨³ãªã„ã€‚é…åˆ»ã—ã¦ã—ã¾ã£ã¦...', next: 'specific_apology', damage: 0 },
                    { text: 'é›»è»ŠãŒé…ã‚Œã¦ã•...', next: 'excuse', damage: 30 }
                ]
            },
            'vague_apology': {
                speaker: 'å½¼å¥³',
                text: 'ã€Œã”ã‚ã‚“ã€ã£ã¦è¨€ãˆã°æ¸ˆã‚€ã¨æ€ã£ã¦ãªã„ï¼Ÿ\nä½•ã«å¯¾ã—ã¦è¬ã£ã¦ã‚‹ã‚ã‘ï¼Ÿ',
                emotion: 'ğŸ˜¡',
                choices: [
                    { text: 'æ€’ã‚‰ã›ãŸã“ã¨ã«ã¤ã„ã¦...', next: 'wrong_focus', damage: 20 },
                    { text: 'å¾…ãŸã›ã¦æ™‚é–“ã‚’ç„¡é§„ã«ã•ã›ãŸã“ã¨ã«ã¤ã„ã¦', next: 'correct_focus', damage: -10 } // Heal slightly
                ]
            },
            'excuse': {
                speaker: 'å½¼å¥³',
                text: 'è¨€ã„è¨³ãªã‚“ã¦èã„ã¦ãªã„ã€‚\nç§ãŒã©ã‚Œã ã‘ã“ã“ã§å¾…ã£ãŸã‹åˆ†ã‹ã£ã¦ã‚‹ï¼Ÿ',
                emotion: 'ğŸ‘¿',
                choices: [
                    { text: 'å¯’ã‹ã£ãŸã‚ˆã­ã€é…æ…®ãŒè¶³ã‚Šãªã‹ã£ãŸã€‚ã”ã‚ã‚“ã€‚', next: 'empathy', damage: -10 },
                    { text: 'ã§ã‚‚æœ¬å½“ã«äº‹æ•…ã§...ï¼ï¼', next: 'gameover', damage: 100 }
                ]
            },
            'specific_apology': {
                speaker: 'å½¼å¥³',
                text: 'â€¦â€¦ã¯ãã€‚ã§ã€ãªã‚“ã§é…ã‚ŒãŸã®ï¼Ÿ',
                emotion: 'ğŸ˜’',
                choices: [
                    { text: 'å¯åŠã—ãŸã€‚æ°—ãŒç·©ã‚“ã§ãŸã€‚', next: 'honesty', damage: 0 },
                    { text: 'ã¡ã‚‡ã£ã¨æ€¥ãªä»•äº‹ãŒå…¥ã£ã¦...', next: 'lie_check', damage: 10 }
                ]
            },
            'wrong_focus': {
                speaker: 'å½¼å¥³',
                text: 'ç§ã®æ©Ÿå«Œã‚’ã¨ã‚ã†ã¨ã—ã¦ã‚‹ã ã‘ã ã‚ˆã­ï¼Ÿ\nã‚‚ã†å¸°ã‚‹ã€‚',
                emotion: 'ğŸ‘‹',
                next: 'gameover'
            },
            'correct_focus': {
                speaker: 'å½¼å¥³',
                text: 'â€¦â€¦ã‚ã‹ã£ã¦ã‚‹ãªã‚‰ã€æœ€åˆã‹ã‚‰ãã†è¨€ã£ã¦ã‚ˆã€‚\nã“ã®1æ™‚é–“ã€æœ¬å½“ã«ä¸å®‰ã ã£ãŸã‚“ã ã‹ã‚‰ã€‚',
                emotion: 'ğŸ˜¢',
                next: 'clear'
            },
            'empathy': {
                speaker: 'å½¼å¥³',
                text: 'â€¦â€¦ã†ã‚“ã€å¯’ã‹ã£ãŸã€‚\næ¬¡ã¯çµ¶å¯¾ã«é€£çµ¡ã—ã¦ã‚ˆã­ã€‚',
                emotion: 'ğŸ˜”',
                next: 'clear'
            },
            'honesty': {
                speaker: 'å½¼å¥³',
                text: 'æ­£ç›´ã§ã‚ˆã‚ã—ã„ã€‚\nãŠè©«ã³ã«ç¾å‘³ã—ã„ãƒ©ãƒ³ãƒã€å¥¢ã£ã¦ã‚ˆã­ã€‚',
                emotion: 'ğŸ˜',
                next: 'clear'
            },
            'lie_check': {
                speaker: 'å½¼å¥³',
                text: 'å˜˜ã¤ãã€‚ã•ã£ãSNSã§ã€ŒäºŒåº¦å¯æœ€é«˜ã€ã£ã¦å‘Ÿã„ã¦ãŸã®è¦‹ãŸã‚ã‚ˆã€‚',
                emotion: 'ğŸ’€',
                next: 'gameover'
            },
            'gameover': {
                speaker: 'ã‚·ã‚¹ãƒ†ãƒ ',
                text: 'ã€BAD ENDã€‘\nç›¸æ‰‹ã®ä¿¡é ¼ã¯ã‚¼ãƒ­ã«ãªã£ãŸã€‚\nã€Œä½•ã«å¯¾ã—ã¦æ‚ªã„ã¨æ€ã£ã¦ã„ã‚‹ã‹ã€ã‚’ä¼ãˆãªã„ã¨ã€è¬ç½ªã¯å±Šã‹ãªã„ã€‚',
                emotion: 'â˜ ï¸',
                end: true
            },
            'clear': {
                speaker: 'ã‚·ã‚¹ãƒ†ãƒ ',
                text: 'ã€MISSION COMPLETEã€‘\nèª æ„ãŒä¼ã‚ã£ãŸï¼\nè¬ç½ªã¨ã¯ã€Œäº‹å®Ÿã®ç¢ºèªã€ã¨ã€Œç›¸æ‰‹ã®æ„Ÿæƒ…ã¸ã®ç†è§£ã€ã§ã‚ã‚‹ã€‚',
                emotion: 'ğŸ‰',
                end: true
            }
        },

        // --- SCENARIO 2: Business ---
        'business': {
            'start': {
                speaker: 'ãƒŠãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³',
                text: 'ã‚ãªãŸã¯é‡è¦ãªé¡§å®¢ãƒ‡ãƒ¼ã‚¿ã®å…¥ã£ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª¤ã£ã¦å‰Šé™¤ã—ã¦ã—ã¾ã£ãŸã€‚\nä¸Šå¸ã«å ±å‘Šã—ãªã‘ã‚Œã°ãªã‚‰ãªã„...',
                emotion: 'ğŸ¢',
                next: 'report'
            },
            'report': {
                speaker: 'ä¸Šå¸',
                text: 'ãŠã„ã€ä¾‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã©ã“ã ï¼Ÿ å…±æœ‰ãƒ•ã‚©ãƒ«ãƒ€ã«è¦‹å½“ãŸã‚‰ãªã„ã‚“ã ãŒã€‚',
                emotion: 'ğŸ¤¨',
                choices: [
                    { text: 'ã™ã¿ã¾ã›ã‚“ã€ãƒŸã‚¹ã‚Šã¾ã—ãŸã€‚', next: 'too_casual', damage: 30 },
                    { text: 'ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€‚èª¤ã£ã¦å‰Šé™¤ã—ã¦ã—ã¾ã„ã¾ã—ãŸã€‚', next: 'fact_report', damage: 0 },
                    { text: 'PCã®èª¿å­ãŒæ‚ªãã¦...', next: 'excuse_boss', damage: 40 }
                ]
            },
            'too_casual': {
                speaker: 'ä¸Šå¸',
                text: 'ãƒŸã‚¹ã‚Šã¾ã—ãŸã€ã˜ã‚ƒãªã„ã ã‚ã†ï¼\näº‹ã®é‡å¤§ã•ãŒã‚ã‹ã£ã¦ã‚‹ã®ã‹ï¼ï¼Ÿ',
                emotion: 'ğŸ’¢',
                choices: [
                    { text: 'ä»¥å¾Œæ°—ã‚’ã¤ã‘ã¾ã™ã€‚', next: 'vague_future', damage: 20 },
                    { text: 'å¾©æ—§å¯èƒ½ã‹ã™ãã«ITéƒ¨é–€ã«ç¢ºèªã—ã¾ã™ã€‚', next: 'solution', damage: -10 }
                ]
            },
            'excuse_boss': {
                speaker: 'ä¸Šå¸',
                text: 'é“å…·ã®ã›ã„ã«ã™ã‚‹ãªã€‚ç®¡ç†è²¬ä»»ã¯ãŠå‰ã«ã‚ã‚‹ã€‚\nã§ã€ã©ã†ã™ã‚‹ã‚“ã ï¼Ÿ',
                emotion: 'ğŸ˜ ',
                choices: [
                    { text: 'ãªã‚“ã¨ã‹ã—ã¾ã™ã€‚', next: 'vague_future', damage: 30 },
                    { text: 'ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ç›´è¿‘ã®ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒã—ã¾ã™ã€‚', next: 'solution', damage: 0 }
                ]
            },
            'fact_report': {
                speaker: 'ä¸Šå¸',
                text: 'å‰Šé™¤ã—ãŸã ã¨...ï¼Ÿ\nãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¯ã¨ã£ã¦ã‚ã‚‹ã®ã‹ï¼Ÿ',
                emotion: 'ğŸ˜°',
                choices: [
                    { text: 'ãŸã¶ã‚“å¤§ä¸ˆå¤«ã ã¨æ€ã„ã¾ã™ã€‚', next: 'uncertainty', damage: 20 },
                    { text: 'æ˜¨æ™©ã®è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒæ®‹ã£ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚', next: 'verified', damage: 0 }
                ]
            },
            'vague_future': {
                speaker: 'ä¸Šå¸',
                text: 'å…·ä½“çš„è§£æ±ºç­–ãŒãªã„ãªã‚‰ä¸‹ãŒã‚Œã€‚\nãŠå‰ã«ã¯ã‚‚ã†ä»»ã›ã‚‰ã‚Œãªã„ã€‚',
                emotion: 'ğŸ‘‹',
                next: 'gameover'
            },
            'uncertainty': {
                speaker: 'ä¸Šå¸',
                text: 'ã€ŒãŸã¶ã‚“ã€ã§ä»•äº‹ã‚’ã™ã‚‹ãªï¼\nä»Šã™ãç¢ºèªã—ã‚ï¼ä¿¡é ¼ã§ãã‚“ï¼',
                emotion: 'ğŸ˜¡',
                next: 'gameover'
            },
            'solution': {
                speaker: 'ä¸Šå¸',
                text: '...ã‚ã‹ã£ãŸã€‚æœ€å„ªå…ˆã§å¾©æ—§ä½œæ¥­ã«ã‚ãŸã‚Œã€‚\nå ±å‘Šã®æ—©ã•ã¨å…·ä½“ç­–ãŒã‚ã£ãŸã‹ã‚‰ä»Šå›ã¯è¨±ã™ã€‚æ¬¡ã¯ç„¡ã„ãã€‚',
                emotion: 'ğŸ˜¤',
                next: 'clear'
            },
            'verified': {
                speaker: 'ä¸Šå¸',
                text: 'ãã†ã‹ã€ä¸å¹¸ä¸­ã®å¹¸ã„ã ã€‚\nã™ãã«å¾©æ—§ä½œæ¥­ã«å…¥ã‚Œã€‚å ±å‘Šã”è‹¦åŠ´ã€‚',
                emotion: 'ğŸ˜Œ',
                next: 'clear'
            },
            'gameover': {
                speaker: 'ã‚·ã‚¹ãƒ†ãƒ ',
                text: 'ã€BAD ENDã€‘\nãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å¤–ã•ã‚ŒãŸã€‚\nãƒ“ã‚¸ãƒã‚¹ã®è¬ç½ªã§ã¯ã€ŒåŸå› ã€ã¨ã€Œè§£æ±ºç­–ã€ã®æç¤ºãŒå¿…é ˆã§ã‚ã‚‹ã€‚',
                emotion: 'ğŸ“‰',
                end: true
            },
            'clear': {
                speaker: 'ã‚·ã‚¹ãƒ†ãƒ ',
                text: 'ã€MISSION COMPLETEã€‘\nè¿…é€Ÿãªå ±å‘Šã¨è§£æ±ºç­–ã«ã‚ˆã‚Šä¿¡é ¼ã‚’ç¶­æŒã—ãŸã€‚\nãƒŸã‚¹ã¯éš ã•ãšã€äº‹å®Ÿã¨å¯¾ç­–ã‚’ã‚»ãƒƒãƒˆã§ä¼ãˆã‚ˆã†ã€‚',
                emotion: 'ğŸ’®',
                end: true
            }
        }
    };

    /**
     * Core Functions
     */

    function startGame(scenarioType) {
        gameState.currentScenario = scenarios[scenarioType];
        gameState.currentNodeId = 'start';
        gameState.trust = 100;
        
        // UI Reset
        els.startScreen.style.display = 'none';
        updateTrustDisplay();
        
        // Set Target Name
        els.targetName.innerText = scenarioType === 'romance' ? 'å½¼å¥³' : 'ä¸Šå¸';

        playNode('start');
    }

    function playNode(nodeId) {
        const node = gameState.currentScenario[nodeId];
        gameState.currentNodeId = nodeId;

        // Update UI
        els.speakerName.innerText = node.speaker;
        els.character.innerText = node.emotion;
        
        // Damage effect check
        if(gameState.trust < 50) {
            els.character.style.filter = "grayscale(100%)";
        } else {
            els.character.style.filter = "none";
        }

        // Start Typewriter
        typeWriter(node.text, () => {
            // Callback when typing finishes
            if (node.end) {
                setTimeout(() => {
                    alert("ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚Šã¾ã™");
                    location.reload();
                }, 3000);
                return;
            }

            if (node.choices) {
                showChoices(node.choices);
            } else if (node.next) {
                // Show arrow to indicate click to continue
                els.nextIndicator.style.display = 'block';
                gameState.isWaitingForInput = true;
            }
        });
    }

    function typeWriter(text, onComplete) {
        gameState.isTyping = true;
        gameState.fullText = text;
        gameState.isWaitingForInput = false;
        els.nextIndicator.style.display = 'none';
        els.choicesContainer.style.display = 'none';
        els.messageText.innerHTML = '';

        let i = 0;
        const speed = 40; // ms per char

        gameState.timerId = setInterval(() => {
            els.messageText.innerText += text.charAt(i);
            i++;
            if (i > text.length - 1) {
                finishTyping(onComplete);
            }
        }, speed);
        
        // Store callback for skip functionality
        gameState.onTypingComplete = onComplete;
    }

    function finishTyping(callback) {
        clearInterval(gameState.timerId);
        els.messageText.innerText = gameState.fullText;
        gameState.isTyping = false;
        if (callback) callback();
    }

    function handleDialogueClick() {
        // Case 1: Typing -> Skip to end
        if (gameState.isTyping) {
            finishTyping(gameState.onTypingComplete);
            return;
        }

        // Case 2: Waiting for Next (Non-choice transition)
        if (gameState.isWaitingForInput) {
            const node = gameState.currentScenario[gameState.currentNodeId];
            if (node.next) {
                playNode(node.next);
            }
        }
    }

    function showChoices(choices) {
        els.choicesContainer.innerHTML = '';
        els.choicesContainer.style.display = 'flex';
        
        choices.forEach(choice => {
            const btn = document.createElement('button');
            btn.className = 'choice-btn';
            btn.innerText = `â–¶ ${choice.text}`;
            btn.onclick = (e) => {
                e.stopPropagation(); // Prevent bubbling to dialogue box
                handleChoice(choice);
            };
            els.choicesContainer.appendChild(btn);
        });
    }

    function handleChoice(choice) {
        els.choicesContainer.style.display = 'none';
        
        // Apply damage/heal
        if (choice.damage) {
            gameState.trust -= choice.damage;
            if (gameState.trust > 100) gameState.trust = 100;
            updateTrustDisplay();
            
            // Shake effect if damage taken
            if (choice.damage > 0) {
                els.character.classList.add('shake');
                setTimeout(() => els.character.classList.remove('shake'), 500);
            }
        }

        // Check Game Over by HP
        if (gameState.trust <= 0) {
            gameState.trust = 0;
            updateTrustDisplay();
            playNode('gameover');
        } else {
            playNode(choice.next);
        }
    }

    function updateTrustDisplay() {
        const bar = els.hpBar;
        bar.style.width = `${gameState.trust}%`;
        
        if (gameState.trust > 60) {
            bar.style.backgroundColor = '#f1c40f'; // Yellow/Normal
        } else if (gameState.trust > 30) {
            bar.style.backgroundColor = '#e67e22'; // Orange
        } else {
            bar.style.backgroundColor = '#e74c3c'; // Red
        }
    }

</script>
</body>
</html>
